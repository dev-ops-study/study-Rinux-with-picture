# 사용자 모드로 구현되는 기능
OS는 커널 이외에도 사용자 모드에서 동작하는 다양한 프로그램으로 구성됨. 이는 라이브러리 형태 혹은 단독 프로그램 등으로 이루어짐. 

## 시스템 콜

리눅스는 하드디스크, 마우스, 네트워크 소켓, 심지어 프로세스 정보( /proc)까지 모두 파일 형태로 추상화함. 덕분에 개발자는 대상이 무엇이든 open(), read(), write(), close()라는 동일한 시스템 콜 인터페이스를 사용 가능.

프로세스는 프로세스의 생성이나 하드웨어의 조작 등 커널의 도움이 필요한 경우 시스템 콜을 통해 커널에 처리를 요청. 

### 시스템 콜의 종류
- 프로세스 생성, 삭제
- 메모리 확보, 해제
- 프로세스 간 통신 (IPC)
- 네트워크
- 파일시스템 다루기 
- 파일 다루기 (디바이스 접근)

### CPU의 모드 변경
프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU에서는 인터럽트 이벤트 발생. 인터럽트 이벤트 발생시 CPU는 커널 모드로 전환되며 요청 내용 처리를 위해 커널이 동작. 요청한 내용 처리가 끝나면 커널 내의 시스템 콜 처리 종료. 그리고 다시 사용자 모드로 돌아가 프로세스의 동작 진행. 

유저 프로세스에서는 CPU 모드를 직접 변경하지 못함. 무조건 시스템 콜 필요!

### 시스템 콜 호출의 동작 순서
cat hello.txt 실행 시 시스템 콜 흐름

사용자가 셸에서 명령어를 입력한 순간부터 출력까지의 과정

1. 프로세스 생성 단계 (fork, execve)
fork(): 현재 실행 중인 셸이 자기 자신을 복제하여 새로운 프로세스를 만듬.

execve(): 복제된 프로세스 위에서 cat 프로그램을 로드하고 실행. 이때 cat 실행 파일이 메모리에 올라옴.

2. 파일 접근 단계 (open)
open("hello.txt", ...): 커널에게 해당 파일을 열어달라고 요청. 
커널은 권한을 확인하고, 파일에 접근할 수 있는 통로인 File Descriptor(FD) 번호를 프로세스에게 넘겨줌.

3. 데이터 로드 및 출력 단계 (read, write)
read(fd, buffer, ...): 커널에 "파일의 내용을 읽어줘"라고 요청.
->
CPU가 커널 모드로 전환됨.
->
커널은 저장 장치(SSD/HDD)에서 데이터를 가져와 메모리(커널 영역)에 올림.
->
그 데이터를 사용자 프로세스의 메모리 공간(버퍼)으로 복사.
->
write(1, buffer, ...): 커널에 "읽어온 데이터를 표준 출력(1번 FD, 보통 터미널)으로 보내줘"라고 요청. 
다시 커널 모드에서 디바이스 드라이버를 통해 모니터에 텍스트가 표시됨.

4. 정리 단계 (close, exit)
- close(fd): 열었던 파일 통로를 닫음.
- exit(): cat 프로세스를 종료하고 자원을 반납.

### 실험

### 시스템 콜의 소요 시간

## 시스템 콜의 wrapper 함수
시스템 콜은 보통의 함수 호출과는 다르게 C언어 등의 고급 언어에서는 직접 호출 불가함. 아키텍처에 의존하는 어셈블리 코드를 사용해 호출할 필요가 있는데, OS 덕분에 시스템 콜 wrapper 함수 사용 가능해짐. 

## 표준 C 라이브러리
애플리케이션 (printf) → 표준 C 라이브러리/glibc (내부적으로 write 호출) → 시스템 콜 Wrapper → 커널 (하드웨어 조작)

### OS가 제공하는 프로그램
- 시스템 초기화: init
- OS의 동작 바꿈: sysctl, nice, sync
- 파일 관련: touch, mkdir
- 텍스트 데이터 가공: grep, sort, uniq
- 성능 측정: sar, iostat
- 컴파일러: gcc
- 스크립트 언어 실행 환경: perl, python, ruby
- 셸: bash, zsh
- 윈도우 시스템: X
